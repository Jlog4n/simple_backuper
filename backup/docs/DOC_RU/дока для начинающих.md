# Для кого предназначено руководство?

Руководство (или документация) предназначена для тех людей, которые хотят разобраться в скрипте. Здесь будут объяснения практически всех ключевых слов и терминов понятными словами.
Важно! Для технического разбора, прошу перейти в каталог проекта `"doc for developers"`, там объяснение подходит для уже "бывалых" людей.
# Что делает скрипт?

Программа служит для резервного копирования  файлов (бэкапа) из одной директории (папки) в другую.
# Совместимость систем

**Скрипт предназначен для Linux и MacOS операционных систем.**
Стоит сказать, что код, между этими двумя ОС, будет отличаться только путями.
Для начало сделаем разбор для Linux, после уже для MacOS.

*********
# Код бэкапа для Linux

```bash
#!/bin/bash

BACKUP_DIR="/home/user/backups" # ВМЕСТО user СТАВЬТЕ СВОЙ НИКНЕЙМ
SOURCE_DIR="/home/user/documents" # ВМЕСТО user СТАВЬТЕ СВОЙ НИКНЕЙМ
BACKUP_NAME="backup_$(date +%Y%m%d_%H%M%S).tar.gz"

mkdir -p "$BACKUP_DIR"

echo "Создаем бэкап..."
tar -czf "$BACKUP_DIR/$BACKUP_NAME" "$SOURCE_DIR"

if [ $? -eq 0 ]; then
    echo "Бэкап успешно создан: $BACKUP_NAME"
else
    echo "Ошибка при создании бэкапа!"
    exit 1
fi
```

# Построчный разбор

# shebang. Что это?

Для того чтобы наш скрипт работал, мы должны "сказать" системе какой интерпретатор мы должны использовать, в нашем случае это `bash`. Как результат, у нас получится следующаяя строка:

```
#!/bin/bash
```

# Объяснение логики переменных

Нам нужно определиться откуда брать данные, а после куда их перемещать. В этом нам помогут переменные, внутри которых мы будем помещать сначала путь для источника (той переменны, из которой мы будем брать наш будущий бэкап), а после путь для хранения результата (бэкапа).

```
BACKUP_DIR="/home/user/backups"
SOURCE_DIR="/home/user/documents"
```

* `BACKUP_DIR` - переменная ,которая хранит в себе путь к директории `backups` - директория хранения результата.
* `SOURCE_DIR` - переменная, которая берет из `documents` файл для резервного копирования.
**ВАЖНО! Вместо `user` нужно вставить свой никнейм!**

В дополнении, как вы можете видеть в коде, мы создали еще одну переменную  - `BACKUP_NAME`, она служит названием бэкапа и генерирует их с текстом, временной меткой и расширением как:
`"backup_YYYYmmdd_HHMMSS.tar.gz`.

объяснение временной метки:
`Y` - year (год);
`m` - month (месяц);
`d` - day (день);
`H` - hour (час);
`M` - minute (час);
`S` - second (секунда).

**ПРИМЕР**
Представим такую ситуацию, что пользователь решил воспользоваться нашей программой и сделал бэкап 2025 года, 4 октября и ровно в 12:25, тогда бэкап у него будет называться как:
`backup_2025104_122500`
# Создание недостающей директории

Следующий кусок кода выглядит так:

```
mkdir -p "$BACKUP_DIR"
```

`mkdir` позволяет создать в системе директорию, а его параметр `-p` служит созданием "недостающей" цепочки директорий, которые, в нашем случае, ведут к `BACKUP_DIR` (`backups`).
Просто представьте, если бы у пользователя не было бы этой директории - то и результата бы тоже не было, ведь именно этот каталог и служит хранением бэкапов!
# Архив

```
echo "Создаем бэкап..."
tar -czf "$BACKUP_DIR/$BACKUP_NAME" "$SOURCE_DIR"
```

`echo` - команда, при котором он выводит текст, в нашем случае это `Создаем бэкап...`.

Стоит сразу сказать, что в директорию для хранения бэкапов - `backups` мы будем помещать архивы, в которых и будут хранится файлы-дубликаты.

- **Бэкап** — это **быстрая копия для восстановления**. Бэкапы часто перезаписываются, живут недолго (дни, недели) и должны быть быстрыми для развертывания.
- **Архив** — это **долгосрочная копия для хранения**. Он не предназначен для быстрого восстановления работы системы.

Теперь после объяснения разницы, предлагаю разобрать строку
```
tar -czf "$BACKUP_DIR/$BACKUP_NAME" "$SOURCE_DIR"
```
`tar` - команда, которая создает архив.
`-czf` - комбинация параметров для tar, где:
1) `c` - создает архив.
2) `z` - преобразовывает архив в расширение `.gzip`.
3) `f` - дает имя архивам.

Параметр `f` для `tar` будет давать имя архиву по принципу:
`"файл архива" "исходная директория"`.

# Разбор условной конструкции

Теперь проверим, являются ли наши действия истинными (true) или ложными (false)
```
if [ $? -eq 0 ]; then
    echo "Бэкап успешно создан: $BACKUP_NAME"
else
    echo "Ошибка при создании бэкапа!"
    exit 1
fi
```

Отрывок кода читается как:
Если последнее завершенное действие (в нашем случае это архивация) равна 0 (в Bash это означает тоже самое, что и истина), то тогда выполни:
```
    echo "Бэкап успешно создан: $BACKUP_NAME"
```
на месте `$BACKUP_NAME` должно подставляться значение вместо него, в нашем случае выведется имя бэкапа.

Иначе (если последнее завершенное действие не равно 0), то тогда выполни:
```
    echo "Ошибка при создании бэкапа!"
    exit 1
```
после `echo` идет `exit 1`, что означает верни 1 (в bash это тоже самое что и ложь).

последняя строка `fi` просто заканчивает условие.

*******
# Код бэкапа для MacOS

```bash
#!/bin/bash

BACKUP_DIR="/Users/user/backups" # ВМЕСТО user СТАВЬТЕ СВОЙ НИКНЕЙМ
SOURCE_DIR="/Users/user/documents" # ВМЕСТО user СТАВЬТЕ СВОЙ НИКНЕЙМ
BACKUP_NAME="backup_$(date +%Y%m%d_%H%M%S).tar.gz"

mkdir -p "$BACKUP_DIR"

echo "Создаем бэкап..."
tar -czf "$BACKUP_DIR/$BACKUP_NAME" "$SOURCE_DIR"

if [ $? -eq 0 ]; then
    echo "Бэкап успешно создан: $BACKUP_NAME"
else
    echo "Ошибка при создании бэкапа!"
    exit 1
fi
```

Единственное различие между Linux в том, что при указании пути мы пишем не `/home/`, а `/Users/`.